<!DOCTYPE html>

<!--
	Това е демо-шаблон на първото домашно задание по ОКГ.
	Вижте коментарите във файла, за да разберете къде да променяте.
	
	Разделяне/слепване на двете части на йероглифа:
		клик с ляв бутон или клавиш "интервал"
		
	Показване/скриване на рамката:
		клик с десен бутон или някой друг клавиш
-->
	
<html>
	<head>
		<script src="three.min.js"></script>
        <script src="kanji.js"></script>
        <script src="THREE.CSG.js"></script>        
	</head>
	
	<body onload="main()">
		<!-- В тага h1 си напишете факултетния номер, групата в Мудъл и двете си имена-->
	    	<h1>ф.н. 81394 &ndash; група 3 &ndash; Антони Калоферов</h1>

		<!-- В този script таг напишете кода си за създаване на
		йероглифа в две половини, разделени с диагонална черта
		от горе-ляво до долу-дясно. Кодът по-долу е само примерен.
		Махнете го и сложете вашия код на негово място. -->
		<script>
			// Елементите, които принадлежат на горната-дясна половина
			// на йероглифа ги добавете към обекта PART1, а елементите
			// на долната-лява половина - в PART2.
			
			// Кодът по-надолу създава две стъпаловидни половини на
			// плочка; целта е да се покаже как да използвате двата
			// обекта PART1 и PART2 (те са създадени в kanji.js и
			// пак от там се манипулират, затова не им променяйте
			// имената).
			
			// Създаваме си материал за елементите - добре е да не
			// е прекалено ярък или тъмен, за да се виждат добре нещата.
			var material = new THREE.MeshPhongMaterial({color:'gray',shininess:100});
            
            /////////////////////////////////////////////////////////////
            var geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(-7.5, 10, 0));
            geometry.vertices.push(new THREE.Vector3(7.5, -10, 0));
            var line = new THREE.Line(geometry, material);
            line.position.set(0, 0, 3.1)
            /////////////////////////////////////////////////////////////

            //mid segment of kanji
            var mid_bottom = new THREE.Mesh( new THREE.BoxGeometry(14.5,1,1), material );
            mid_bottom.position.set(0,-4,6);
            var mid_top = new THREE.Mesh( new THREE.BoxGeometry(12,1,1), material );
			mid_top.position.set(0,-1.5,6);
            var mid_left = new THREE.Mesh( new THREE.BoxGeometry(1,4,1), material );
            mid_left.position.set(-2.1,-1.75,6);
            var mid_right = new THREE.Mesh( new THREE.BoxGeometry(1,4,1), material );
            mid_right.position.set(2.1,-1.75,6);
            
            
            //left number 2 looking part of the kanji
            var left_2_top = new THREE.Mesh( new THREE.BoxGeometry(5.5,1,1), material );
            left_2_top.position.set(-3.25,5,6);
            var left_2_right = new THREE.Mesh( new THREE.BoxGeometry(1,1,1), material );
            left_2_right.position.set(-1,4,6);
            var left_2_mid = new THREE.Mesh( new THREE.BoxGeometry(5.5,1,1), material );
            left_2_mid.position.set(-3.25,3,6);
            var left_2_left = new THREE.Mesh( new THREE.BoxGeometry(1,1,1), material );
            left_2_left.position.set(-5.5,2,6);
            var left_2_bottom = new THREE.Mesh( new THREE.BoxGeometry(3.5,1,1), material );
            left_2_bottom.position.set(-3.25,1,6);
            //small curve at the left bottom part of the 2 using spline and cylinders along the spline
            var left_2_curve_left = new THREE.SplineCurve( [
                new THREE.Vector2( -5.5, 1.5 ),
                new THREE.Vector2( -5.45, 1.05 ),
                new THREE.Vector2( -5, 1 )
            ] );

            left_2_curve_left.getSpacedPoints(60).forEach(function(element) {
                var cylinder = new THREE.Mesh( new THREE.CylinderGeometry(0.5,0.5,1,50), material );
                cylinder.position.set(element.x, element.y ,6);
                cylinder.rotation.x = Math.PI/2;
                part1.add(cylinder)
            });
            //tail of left 2
            var left_2_curve_right = new THREE.SplineCurve( [
                new THREE.Vector2( -1.5, 1 ),
                new THREE.Vector2( -1, 1.034 ),
                new THREE.Vector2( -0.6, 1.3 ),
                new THREE.Vector2( -0.1-0.2, 2.2-0.2 )
            ] );
            left_2_curve_right.getSpacedPoints(60).forEach(function(element) {
                var cylinder = new THREE.Mesh( new THREE.CylinderGeometry(0.5,0.5,1,50), material );
                cylinder.position.set(element.x, element.y ,6);
                cylinder.rotation.x = Math.PI/2;
                part1.add(cylinder)
            });
            var tail_cube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1,), material);
            tail_cube.position.set(-0.3, 2, 6);
            tail_cube.rotation.z = 1.21;
            part1.add(tail_cube);

            //right number 2 looking part of the kanji
            var right_2_top = new THREE.Mesh( new THREE.BoxGeometry(5.5,1,1), material );
            right_2_top.position.set(3.25,5,6);
            var right_2_right = new THREE.Mesh( new THREE.BoxGeometry(1,1,1), material );
            right_2_right.position.set(5.5,4,6);
            var right_2_mid = new THREE.Mesh( new THREE.BoxGeometry(5.5,1,1), material );
            right_2_mid.position.set(3.25,3,6);
            var right_2_left = new THREE.Mesh( new THREE.BoxGeometry(1,1,1), material );
            right_2_left.position.set(1,2,6);  
            var right_2_bottom = new THREE.Mesh( new THREE.BoxGeometry(3.5,1,1), material );
            right_2_bottom.position.set(3.25,1,6); 
            //small curve at right bottom of the 2 using spline and cylinders 
            var right_2_curve_left = new THREE.SplineCurve( [
                // new THREE.Vector2( 1, 1.5 ),
                // new THREE.Vector2( 1.05, 1.05 ),
                // new THREE.Vector2( 1.5, 1 )
                new THREE.Vector2( 1, 1.5 ),
                new THREE.Vector2( 1.05, 1.05 ),
                new THREE.Vector2( 1.5, 1 )
            ] );
            right_2_curve_left.getSpacedPoints(60).forEach(function(element) {
                var cylinder = new THREE.Mesh( new THREE.CylinderGeometry(0.5,0.5,1,50), material );
                cylinder.position.set(element.x, element.y ,6);
                cylinder.rotation.x = Math.PI/2;
                part1.add(cylinder)
            });        

            //tail of right 2
            var right_2_curve_right = new THREE.SplineCurve( [
                new THREE.Vector2( 5, 1 ),
                new THREE.Vector2( 5.5, 1.007 ),
                new THREE.Vector2( 6, 1.1 ),
                new THREE.Vector2( 6.35, 1.5 ),
                new THREE.Vector2( 6.43, 2 )
            ] );
            right_2_curve_right.getSpacedPoints(60).forEach(function(element) {
                var cylinder = new THREE.Mesh( new THREE.CylinderGeometry(0.5,0.5,1,50), material );
                cylinder.position.set(element.x, element.y ,6);
                cylinder.rotation.x = Math.PI/2;
                part1.add(cylinder)
            });
            var tail_cube1 = new THREE.Mesh(new THREE.BoxGeometry(1,1,1,), material);
            tail_cube1.position.set(6.43, 2, 6);
            tail_cube1.rotation.z = 1.46;
            part1.add(tail_cube1);
            
            var tail_cube_triangle_end = new THREE.Mesh(new THREE.CylinderGeometry(0.615,0.615, 1, 3), material);
            tail_cube_triangle_end.position.set(6.38,2.29,6);
            tail_cube_triangle_end.rotation.x = Math.PI/2;
            tail_cube_triangle_end.rotation.y = -0.27;
            part1.add(tail_cube_triangle_end);

            //bottom left curved line
            var left_bottom = new THREE.SplineCurve( [
                new THREE.Vector2( -6.8, -7 ),
                new THREE.Vector2( -5.2, -6.72 ),
                new THREE.Vector2( -3.5, -6.18 ),
                new THREE.Vector2( -2, -5.4 )
            ] );
            left_bottom.getSpacedPoints(60).forEach(function(element) {
                var cylinder = new THREE.Mesh( new THREE.CylinderGeometry(0.5,0.5,1,50), material );
                cylinder.position.set(element.x, element.y ,6);
                cylinder.rotation.x = Math.PI/2;
                part1.add(cylinder)
            });
            var bottom_left_line_top_cube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1,), material);
            bottom_left_line_top_cube.position.set(-2, -5.4, 6);
            bottom_left_line_top_cube.rotation.z = 0.52;
            part1.add(bottom_left_line_top_cube);
            var bottom_left_line_bottom_cube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1,), material);
            bottom_left_line_bottom_cube.position.set(-6.8, -7, 6);
            bottom_left_line_bottom_cube.rotation.z = 0.14;
            part1.add(bottom_left_line_bottom_cube);

            var bottom_left_line_left_cube_triangle = new THREE.Mesh(new THREE.CylinderGeometry(0.65,0.65, 1, 3), material);
            bottom_left_line_left_cube_triangle.position.set(-7.17,-6.92,6);
            bottom_left_line_left_cube_triangle.rotation.x = Math.PI/2;
            bottom_left_line_left_cube_triangle.rotation.y = -0.1;
            part1.add(bottom_left_line_left_cube_triangle);

            var bottom_left_line_left_cube_triangle = new THREE.Mesh(new THREE.CylinderGeometry(0.61,0.61, 1, 3), material);
            bottom_left_line_left_cube_triangle.position.set(-1.73,-5.33,6);
            bottom_left_line_left_cube_triangle.rotation.x = Math.PI/2;
            bottom_left_line_left_cube_triangle.rotation.y = -0.9;
            part1.add(bottom_left_line_left_cube_triangle);

            var mS = (new THREE.Matrix4()).identity();
            mS.elements[5] = -1;
            mS.elements[10] = -1;
            
            var right_bottom = new THREE.SplineCurve( [
                new THREE.Vector2( 2.2, -7 ),
                new THREE.Vector2( 3.8, -6.72 ),
                new THREE.Vector2( 5.5, -6.18 ),
                new THREE.Vector2( 7, -5.4 )
            ] );
            
            var path = new THREE.Path( right_bottom.getPoints( 50 ) );
            var geometry1 = path.createPointsGeometry( 50 );
            geometry1.applyMatrix(mS);

            geometry1.vertices.forEach(function(element) {
                var cylinder = new THREE.Mesh( new THREE.CylinderGeometry(0.5,0.5,1,50), material );
                cylinder.position.set(element.x - 0.4, element.y-12.4 ,6);
                cylinder.rotation.x = Math.PI/2;
                part1.add(cylinder)
            });
            var bottom_right_line_top_cube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1,), material);
            bottom_right_line_top_cube.position.set(1.8, -5.4, 6);
            bottom_right_line_top_cube.rotation.z = -0.14;
            part1.add(bottom_right_line_top_cube);
            var bottom_right_line_bottom_cube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1,), material);
            bottom_right_line_bottom_cube.position.set(6.6, -7, 6);
            bottom_right_line_bottom_cube.rotation.z = -0.51;
            part1.add(bottom_right_line_bottom_cube);

            var bottom_right_line_left_cube_triangle = new THREE.Mesh(new THREE.CylinderGeometry(0.65,0.65, 1, 3), material);
            bottom_right_line_left_cube_triangle.position.set(1.38,-5.47,6);
            bottom_right_line_left_cube_triangle.rotation.x = Math.PI/2;
            bottom_right_line_left_cube_triangle.rotation.y = -1;
            part1.add(bottom_right_line_left_cube_triangle);

            //USING THREE.CSG.js FROM HERE ON

            var mid_bottom_csg = THREE.CSG.fromMesh(mid_bottom);
            var mid_top_csg = THREE.CSG.fromMesh(mid_top);
            var mid_left_csg = THREE.CSG.fromMesh(mid_left);
            var mid_right_csg = THREE.CSG.fromMesh(mid_right);
            var left_2_top_csg = THREE.CSG.fromMesh(left_2_top);
            var left_2_right_csg = THREE.CSG.fromMesh(left_2_right);
            var left_2_mid_csg = THREE.CSG.fromMesh(left_2_mid);
            var left_2_left_csg = THREE.CSG.fromMesh(left_2_left);
            var left_2_bottom_csg = THREE.CSG.fromMesh(left_2_bottom);
            






            // var path = new THREE.Path( right_bottom.getPoints( 50 ) );
            // var geometry1 = path.createPointsGeometry( 50 );
            // geometry1.applyMatrix(mS);
            // var material1    = new THREE.LineBasicMaterial( { color : 0xff0000 } );
            // var splineObject = new THREE.Line( geometry1, material1 );
            // splineObject.position.set(-0.5, -12.2, 6.6);
            // part1.add(splineObject);

                        

            /////////////////////////////////////////////////////////////
			// // Дефинираме елементите на горната-дясна половина (с имена по наш избор).
			// var cube1 = new THREE.Mesh( new THREE.BoxGeometry(10,10,6), material );
			// cube1.position.set(2.5,5,0);
			// var cube2 = new THREE.Mesh( new THREE.BoxGeometry(5,5,6), material );
			// cube2.position.set(-5,7.5,0);
			// var cube3 = new THREE.Mesh( new THREE.BoxGeometry(5,5,6), material );
			// cube3.position.set(5,-2.5,0);
            
            
			// Добавяме ги към обекта PART1 (името е фиксирано).
            part1.add(line, mid_bottom, mid_top, mid_left,
                 mid_right, left_2_top, left_2_right, left_2_mid, left_2_left,
                  right_2_left, right_2_mid, right_2_right, right_2_top, left_2_bottom, right_2_bottom);
            
			
			// // Дефинираме елементите на долната-лява половина (с имена по наш избор).
			// var cube1 = new THREE.Mesh( new THREE.BoxGeometry(10,10,6), material );
			// cube1.position.set(-2.5,-5,0);
			// var cube2 = new THREE.Mesh( new THREE.BoxGeometry(5,5,6), material );
			// cube2.position.set(5,-7.5,0);
			// var cube3 = new THREE.Mesh( new THREE.BoxGeometry(5,5,6), material );
			// cube3.position.set(-5,2.5,0);
			
			// // Добавяме ги към обекта PART2 (името е фиксирано).
			// part2.add( cube1, cube2, cube3 );

			// Файлът kanji.js се грижи да нарисува земята и двете половини
			// на йероглифа; грижи се и раздалечаването и приближаването на
			// тези половини; показване/скриване на рамката; звукови ефекти
			// и потрепване. Това е само за ваша информация, ако евентуално
			// се чудете къде се прави магията. Това май е най-подравненият
			// коментар досега -- както отляво, така и отдясно е подравнен.
		</script>
	</body>
</html>